        -:    0:Source:randomtestcard1.c
        -:    0:Graph:randomtestcard1.gcno
        -:    0:Data:randomtestcard1.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/* Aaron Berns
        -:    2: * randomtestcard1.c tests playAdventurer function
        -:    3: */
        -:    4:
        -:    5:#include "dominion.h"
        -:    6:#include "dominion_helpers.h"
        -:    7:#include <string.h>
        -:    8:#include <stdio.h>
        -:    9:#include <stdlib.h>
        -:   10:#include <assert.h>
        -:   11:#include <time.h>
        -:   12:#include "rngs.h"
        -:   13:
        -:   14:#define DEBUG 0
        -:   15:#define NOISY_TEST 1
        -:   16:
function Adventurer called 200000 returned 100% blocks executed 100%
   200000:   17:void Adventurer(struct gameState *state, int currentPlayer) {
        -:   18:
   200000:   19:  int drawntreasure = 0; //bug
        -:   20:  int cardDrawn;
   200000:   21:  int z = 0;
        -:   22:  int temphand[MAX_HAND];
        -:   23:  
  3307223:   24:    while(drawntreasure<2){
branch  0 taken 94%
branch  1 taken 6% (fallthrough)
  2907223:   25:        printf("drawntreasure: %d, cardDrawn: %d, z: %d\n",  drawntreasure, cardDrawn, z);
call    0 returned 100%
        -:   26:
  2907223:   27:        if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
       21:   28:          shuffle(currentPlayer, state);
call    0 returned 100%
        -:   29:        }
        -:   30:
  2907223:   31:        drawCard(currentPlayer, state);
call    0 returned 100%
  2907223:   32:        cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
  2907223:   33:        if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold) {
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
branch  2 taken 96% (fallthrough)
branch  3 taken 4%
branch  4 taken 4% (fallthrough)
branch  5 taken 96%
   400000:   34:          drawntreasure++;
        -:   35:        }
        -:   36:        else{
  2507223:   37:          temphand[z]=cardDrawn;
  2507223:   38:          state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
  2507223:   39:          z++;
        -:   40:        }
        -:   41:      }
        -:   42:
  2907223:   43:      while(z-1>=0){
branch  0 taken 93%
branch  1 taken 7% (fallthrough)
  2507223:   44:	    state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
  2507223:   45:	    z=z-1;
        -:   46:      }
   200000:   47:        printf("\n");
call    0 returned 100%
   200000:   48:}
        -:   49:
function checkAdventurer called 200000 returned 100% blocks executed 84%
   200000:   50:void checkAdventurer(int p, struct gameState *post) {
        -:   51:    struct gameState pre;
        -:   52:
   200000:   53:    memcpy (&pre, post, sizeof(struct gameState));
        -:   54:
   200000:   55:    Adventurer(post, p);
call    0 returned 100%
        -:   56:
        -:   57:
        -:   58:    // last two cards in hand should be treasure cards
   200000:   59:    assert (post->hand[p][post->handCount[p]-1] == copper || post->hand[p][post->handCount[p]-1] == silver || post->hand[p][post->handCount[p]-1] == gold);
branch  0 taken 57% (fallthrough)
branch  1 taken 43%
branch  2 taken 50% (fallthrough)
branch  3 taken 50%
branch  4 taken 28% (fallthrough)
branch  5 taken 72%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
call    8 never executed
   200000:   60:    assert (post->hand[p][post->handCount[p]-2] == copper || post->hand[p][post->handCount[p]-2] == silver || post->hand[p][post->handCount[p]-2] == gold);
branch  0 taken 57% (fallthrough)
branch  1 taken 43%
branch  2 taken 50% (fallthrough)
branch  3 taken 50%
branch  4 taken 28% (fallthrough)
branch  5 taken 72%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
call    8 never executed
        -:   61:
        -:   62:    // deck = change in discard pile - 2 treasure cards
   200000:   63:    printf("postDeck: %d, preDeck: %d, postDis: %d, preDis: %d\n", post->deckCount[p], pre.deckCount[p], post->discardCount[p], pre.discardCount[p]);
call    0 returned 100%
   200000:   64:    assert (post->deckCount[p] == pre.deckCount[p] - (post->discardCount[p] - pre.discardCount[p]) - 2);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:   65:
        -:   66:
        -:   67:/*
        -:   68:  if (pre.deckCount[p] > 0) {
        -:   69:    pre.handCount[p]++;
        -:   70:    pre.hand[p][pre.handCount[p]-1] = pre.deck[p][pre.deckCount[p]-1];
        -:   71:    pre.deckCount[p]--;
        -:   72:  } else if (pre.discardCount[p] > 0) {
        -:   73:    memcpy(pre.deck[p], post->deck[p], sizeof(int) * pre.discardCount[p]);
        -:   74:    memcpy(pre.discard[p], post->discard[p], sizeof(int)*pre.discardCount[p]);
        -:   75:    pre.hand[p][post->handCount[p]-1] = post->hand[p][post->handCount[p]-1];
        -:   76:    pre.handCount[p]++;
        -:   77:    pre.deckCount[p] = pre.discardCount[p]-1;
        -:   78:    pre.discardCount[p] = 0;
        -:   79:  }
        -:   80:
        -:   81:  assert (r == 0);
        -:   82:
        -:   83:  assert(memcmp(&pre, post, sizeof(struct gameState)) == 0);
        -:   84:  */
   200000:   85:}
        -:   86:
function main called 1 returned 100% blocks executed 97%
        1:   87:int main () {
        -:   88:
        -:   89:  int i, n, r, p, deckCount, discardCount, handCount;
        -:   90:
        1:   91:  int k[10] = {adventurer, council_room, feast, gardens, mine,
        -:   92:	       remodel, smithy, village, baron, great_hall};
        -:   93:
        -:   94:  struct gameState G;
        -:   95:
        1:   96:  printf ("Testing playAdventurer.\n");
call    0 returned 100%
        -:   97:
        1:   98:  printf ("RANDOM TESTS.\n");
call    0 returned 100%
        -:   99:
        1:  100:  srand(time(NULL));
call    0 returned 100%
call    1 returned 100%
        -:  101:  //SelectStream(2);
        -:  102:  //PutSeed(3);
        -:  103:
   200001:  104:  for (n = 0; n < 200000; n++) {
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
5260200000:  105:    for (i = 0; i < sizeof(struct gameState); i++) {
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
5260000000:  106:      ((char*)&G)[i] = ((rand() % (256 + 1 - 0) + 0));
call    0 returned 100%
        -:  107:    }
   200000:  108:    p = ((rand() % (3 + 1 - 0) + 0));
call    0 returned 100%
   200000:  109:    G.deckCount[p] = ((rand() % (MAX_DECK + 1 - 10) + 10));
call    0 returned 100%
   200000:  110:    G.discardCount[p] = ((rand() % (100 + 1 - 0) + 0));
call    0 returned 100%
   200000:  111:    G.handCount[p] = ((rand() % (MAX_HAND - 5) + 5));
call    0 returned 100%
 50663688:  112:    for (i = 0; i < G.handCount[p]; ++i) {
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
 50463688:  113:        G.hand[p][i] = ((rand() % (24 + 1 - 0) + 0));
call    0 returned 100%
        -:  114:    }
 51134352:  115:    for (i = 0; i < G.deckCount[p]; ++i) {
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
 50934352:  116:        G.deck[p][i] = ((rand() % (24 + 1 - 0) + 0));
call    0 returned 100%
        -:  117:    }
 10216817:  118:    for (i = 0; i < G.discardCount[p]; ++i) {
branch  0 taken 98%
branch  1 taken 2% (fallthrough)
 10016817:  119:        G.discard[p][i] = ((rand() % (24 + 1 - 0) + 0));
call    0 returned 100%
        -:  120:    }
        -:  121:
        -:  122:    // ensure at least 3 treasure cards in deck
   200000:  123:    int count = 0;
        -:  124:    int randomIndex;
  1000000:  125:    while (count < 3) {
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
   600000:  126:        randomIndex = ((rand() % (G.deckCount[p] + 1 - 0) + 0));
call    0 returned 100%
   600000:  127:        if (G.deck[p][randomIndex] != copper || G.deck[p][randomIndex] != silver || G.deck[p][randomIndex] != gold) {
branch  0 taken 5% (fallthrough)
branch  1 taken 95%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 never executed
branch  5 never executed
   600000:  128:            G.deck[p][randomIndex] = copper;
   600000:  129:            count++;
        -:  130:        }
        -:  131:    }
        -:  132:
   200000:  133:    checkAdventurer(p, &G);
call    0 returned 100%
   200000:  134:    printf("END OF TEST %d\n", n);
call    0 returned 100%
        -:  135:  }
        -:  136:
        1:  137:  printf ("ALL TESTS OK\n");
call    0 returned 100%
        -:  138:/*
        -:  139:  exit(0);
        -:  140:
        -:  141:  printf ("SIMPLE FIXED TESTS.\n");
        -:  142:  for (p = 0; p < 2; p++) {
        -:  143:    for (deckCount = 0; deckCount < 5; deckCount++) {
        -:  144:      for (discardCount = 0; discardCount < 5; discardCount++) {
        -:  145:	for (handCount = 0; handCount < 5; handCount++) {
        -:  146:	  memset(&G, 23, sizeof(struct gameState)); 
        -:  147:	  r = initializeGame(2, k, 1, &G);
        -:  148:	  G.deckCount[p] = deckCount;
        -:  149:	  memset(G.deck[p], 0, sizeof(int) * deckCount);
        -:  150:	  G.discardCount[p] = discardCount;
        -:  151:	  memset(G.discard[p], 0, sizeof(int) * discardCount);
        -:  152:	  G.handCount[p] = handCount;
        -:  153:	  memset(G.hand[p], 0, sizeof(int) * handCount);
        -:  154:	  checkDrawCard(p, &G);
        -:  155:	}
        -:  156:      }
        -:  157:    }
        -:  158:  }
        -:  159:*/
        1:  160:  return 0;
        -:  161:}
